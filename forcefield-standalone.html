<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Force Field Particle Animator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/framer-motion@10.16.4/dist/framer-motion.js"></script>
    <style>
        body {
            background: linear-gradient(135deg, #0f172a 0%, #581c87 50%, #0f172a 100%);
            font-family: 'Inter', sans-serif;
        }
        .canvas-container {
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        canvas {
            border: 1px solid rgba(168, 85, 247, 0.3);
            border-radius: 8px;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
            cursor: crosshair;
            touch-action: none;
        }
        .control-panel {
            position: fixed;
            right: 1rem;
            top: 1rem;
            width: 320px;
            max-height: 90vh;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(8px);
            border: 1px solid rgba(168, 85, 247, 0.3);
            border-radius: 8px;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
        }
        .control-group {
            padding: 1rem;
            border-bottom: 1px solid rgba(168, 85, 247, 0.2);
        }
        .control-group:last-child {
            border-bottom: none;
        }
        .slider {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: rgba(168, 85, 247, 0.2);
            outline: none;
            -webkit-appearance: none;
        }
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #a855f7;
            cursor: pointer;
        }
        .slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #a855f7;
            cursor: pointer;
            border: none;
        }
        .btn {
            padding: 0.5rem 1rem;
            border: 1px solid rgba(168, 85, 247, 0.5);
            border-radius: 6px;
            background: rgba(168, 85, 247, 0.1);
            color: #e9d5ff;
            cursor: pointer;
            transition: all 0.2s;
        }
        .btn:hover {
            background: rgba(168, 85, 247, 0.2);
        }
        .btn-primary {
            background: rgba(168, 85, 247, 0.3);
        }
        .btn-primary:hover {
            background: rgba(168, 85, 247, 0.4);
        }
    </style>
</head>
<body class="min-h-screen text-white">
    <div class="container mx-auto px-6 py-6">
        <!-- Header -->
        <header class="text-center mb-8">
            <h1 class="text-4xl font-bold mb-2">Force Field Particle Animator</h1>
            <p class="text-purple-300">Transform images into interactive force field animations</p>
        </header>

        <!-- Canvas Container -->
        <div class="canvas-container">
            <canvas id="forceFieldCanvas" width="800" height="600"></canvas>
        </div>

        <!-- Instructions -->
        <div class="text-center mt-4 text-purple-300">
            <p>Move your mouse or touch to create force field effects</p>
        </div>
    </div>

    <!-- Control Panel -->
    <div class="control-panel">
        <div class="control-group">
            <h3 class="text-lg font-semibold mb-4 text-purple-300">Particle Settings</h3>
            
            <div class="mb-4">
                <label class="block text-sm text-purple-200 mb-2">Density</label>
                <input type="range" id="densitySlider" class="slider" min="100" max="5000" value="1000" step="100">
                <div class="text-xs text-purple-400 mt-1" id="densityValue">1000</div>
            </div>

            <div class="mb-4">
                <label class="block text-sm text-purple-200 mb-2">Size</label>
                <input type="range" id="sizeSlider" class="slider" min="1" max="10" value="2" step="0.5">
                <div class="text-xs text-purple-400 mt-1" id="sizeValue">2</div>
            </div>

            <div class="mb-4">
                <label class="block text-sm text-purple-200 mb-2">Shape</label>
                <select id="shapeSelect" class="w-full bg-slate-800 border border-purple-500/30 text-purple-200 rounded px-3 py-2">
                    <option value="circle">Circle</option>
                    <option value="square">Square</option>
                    <option value="triangle">Triangle</option>
                </select>
            </div>
        </div>

        <div class="control-group">
            <h3 class="text-lg font-semibold mb-4 text-purple-300">Force Settings</h3>
            
            <div class="mb-4">
                <label class="block text-sm text-purple-200 mb-2">Effect Radius</label>
                <input type="range" id="radiusSlider" class="slider" min="50" max="300" value="100" step="10">
                <div class="text-xs text-purple-400 mt-1" id="radiusValue">100px</div>
            </div>

            <div class="mb-4">
                <label class="block text-sm text-purple-200 mb-2">Force Strength</label>
                <input type="range" id="strengthSlider" class="slider" min="1" max="10" value="4" step="0.5">
                <div class="text-xs text-purple-400 mt-1" id="strengthValue">4</div>
            </div>

            <div class="mb-4">
                <label class="block text-sm text-purple-200 mb-2">Healing Factor</label>
                <input type="range" id="healingSlider" class="slider" min="10" max="100" value="30" step="5">
                <div class="text-xs text-purple-400 mt-1" id="healingValue">30</div>
            </div>
        </div>

        <div class="control-group">
            <h3 class="text-lg font-semibold mb-4 text-purple-300">Actions</h3>
            
            <div class="grid grid-cols-2 gap-2">
                <button id="resetBtn" class="btn">Reset</button>
                <button id="screenshotBtn" class="btn">Screenshot</button>
                <button id="uploadBtn" class="btn">Upload Image</button>
                <button id="defaultBtn" class="btn btn-primary">Default Image</button>
            </div>

            <div class="mt-4 text-center">
                <div class="text-sm text-purple-300">
                    <span id="particleCount">0</span> particles
                </div>
            </div>
        </div>
    </div>

    <!-- Hidden file input -->
    <input type="file" id="fileInput" accept="image/*" style="display: none;">

    <script>
        // Force Field Particle Animator - Standalone Version
        class Particle {
            constructor(x, y, color, size, shape) {
                this.x = x;
                this.y = y;
                this.originalX = x;
                this.originalY = y;
                this.vx = 0;
                this.vy = 0;
                this.color = color;
                this.size = size;
                this.shape = shape;
            }

            update(mouseX, mouseY, mouseActive, settings) {
                // Apply healing force (return to original position)
                const dx = this.originalX - this.x;
                const dy = this.originalY - this.y;
                this.vx += dx * settings.healingFactor * 0.001;
                this.vy += dy * settings.healingFactor * 0.001;

                // Apply mouse force if active
                if (mouseActive) {
                    const mouseDx = mouseX - this.x;
                    const mouseDy = mouseY - this.y;
                    const distance = Math.sqrt(mouseDx * mouseDx + mouseDy * mouseDy);

                    if (distance < settings.effectRadius) {
                        const force = settings.forceStrength * 0.01 / (distance * 0.1);
                        this.vx -= (mouseDx / distance) * force;
                        this.vy -= (mouseDy / distance) * force;
                    }
                }

                // Apply damping
                this.vx *= 0.95;
                this.vy *= 0.95;

                // Update position
                this.x += this.vx;
                this.y += this.vy;
            }

            draw(ctx) {
                ctx.fillStyle = this.color;
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 1;

                switch (this.shape) {
                    case 'circle':
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                        ctx.fill();
                        break;

                    case 'square':
                        ctx.fillRect(
                            this.x - this.size,
                            this.y - this.size,
                            this.size * 2,
                            this.size * 2
                        );
                        break;

                    case 'triangle':
                        ctx.beginPath();
                        ctx.moveTo(this.x, this.y - this.size);
                        ctx.lineTo(this.x - this.size, this.y + this.size);
                        ctx.lineTo(this.x + this.size, this.y + this.size);
                        ctx.closePath();
                        ctx.fill();
                        break;
                }
            }
        }

        class ForceFieldApp {
            constructor() {
                this.canvas = document.getElementById('forceFieldCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.particles = [];
                this.mouseX = 0;
                this.mouseY = 0;
                this.mouseActive = false;
                this.animationId = null;
                this.settings = {
                    particleDensity: 1000,
                    particleSize: 2,
                    particleShape: 'circle',
                    effectRadius: 100,
                    forceStrength: 4,
                    healingFactor: 30
                };

                this.initializeEventListeners();
                this.initializeControls();
                this.createDefaultImage();
                this.startAnimation();
            }

            initializeEventListeners() {
                // Mouse events
                this.canvas.addEventListener('mousemove', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    this.mouseX = e.clientX - rect.left;
                    this.mouseY = e.clientY - rect.top;
                    this.mouseActive = true;
                });

                this.canvas.addEventListener('mouseleave', () => {
                    this.mouseActive = false;
                });

                // Touch events
                this.canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    const rect = this.canvas.getBoundingClientRect();
                    const touch = e.touches[0];
                    this.mouseX = touch.clientX - rect.left;
                    this.mouseY = touch.clientY - rect.top;
                    this.mouseActive = true;
                });

                this.canvas.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    const rect = this.canvas.getBoundingClientRect();
                    const touch = e.touches[0];
                    this.mouseX = touch.clientX - rect.left;
                    this.mouseY = touch.clientY - rect.top;
                });

                this.canvas.addEventListener('touchend', () => {
                    this.mouseActive = false;
                });
            }

            initializeControls() {
                // Sliders
                const sliders = {
                    density: { element: 'densitySlider', value: 'densityValue', property: 'particleDensity' },
                    size: { element: 'sizeSlider', value: 'sizeValue', property: 'particleSize' },
                    radius: { element: 'radiusSlider', value: 'radiusValue', property: 'effectRadius' },
                    strength: { element: 'strengthSlider', value: 'strengthValue', property: 'forceStrength' },
                    healing: { element: 'healingSlider', value: 'healingValue', property: 'healingFactor' }
                };

                Object.entries(sliders).forEach(([key, config]) => {
                    const slider = document.getElementById(config.element);
                    const valueDisplay = document.getElementById(config.value);
                    
                    slider.addEventListener('input', (e) => {
                        const value = parseFloat(e.target.value);
                        this.settings[config.property] = value;
                        valueDisplay.textContent = key === 'radius' ? `${value}px` : value;
                        
                        if (key === 'density') {
                            this.createDefaultImage();
                        }
                    });
                });

                // Shape selector
                document.getElementById('shapeSelect').addEventListener('change', (e) => {
                    this.settings.particleShape = e.target.value;
                });

                // Buttons
                document.getElementById('resetBtn').addEventListener('click', () => {
                    this.resetParticles();
                });

                document.getElementById('screenshotBtn').addEventListener('click', () => {
                    this.takeScreenshot();
                });

                document.getElementById('uploadBtn').addEventListener('click', () => {
                    document.getElementById('fileInput').click();
                });

                document.getElementById('defaultBtn').addEventListener('click', () => {
                    this.createDefaultImage();
                });

                // File upload
                document.getElementById('fileInput').addEventListener('change', (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        this.loadImage(file);
                    }
                });
            }

            createDefaultImage() {
                const width = this.canvas.width;
                const height = this.canvas.height;
                
                // Create a gradient background
                const gradient = this.ctx.createLinearGradient(0, 0, width, height);
                gradient.addColorStop(0, '#1a1a2e');
                gradient.addColorStop(0.5, '#16213e');
                gradient.addColorStop(1, '#0f3460');

                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(0, 0, width, height);

                // Add some geometric shapes
                this.ctx.fillStyle = '#e94560';
                this.ctx.beginPath();
                this.ctx.arc(width * 0.3, height * 0.3, 50, 0, Math.PI * 2);
                this.ctx.fill();

                this.ctx.fillStyle = '#533483';
                this.ctx.beginPath();
                this.ctx.arc(width * 0.7, height * 0.7, 40, 0, Math.PI * 2);
                this.ctx.fill();

                this.ctx.fillStyle = '#00d4ff';
                this.ctx.fillRect(width * 0.2, height * 0.6, 60, 60);

                this.generateParticles();
            }

            generateParticles() {
                const imageData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
                const { width, height, data } = imageData;
                this.particles = [];

                const step = Math.max(1, Math.floor(Math.sqrt((width * height) / this.settings.particleDensity)));

                for (let y = 0; y < height; y += step) {
                    for (let x = 0; x < width; x += step) {
                        const index = (y * width + x) * 4;
                        const r = data[index];
                        const g = data[index + 1];
                        const b = data[index + 2];
                        const a = data[index + 3];

                        // Skip transparent pixels
                        if (a < 128) continue;

                        const color = `rgb(${r}, ${g}, ${b})`;
                        
                        this.particles.push(new Particle(
                            x, y, color, this.settings.particleSize, this.settings.particleShape
                        ));
                    }
                }

                document.getElementById('particleCount').textContent = this.particles.length;
            }

            resetParticles() {
                this.particles.forEach(particle => {
                    particle.x = particle.originalX;
                    particle.y = particle.originalY;
                    particle.vx = 0;
                    particle.vy = 0;
                });
            }

            takeScreenshot() {
                const link = document.createElement('a');
                link.download = `forcefield_${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.png`;
                link.href = this.canvas.toDataURL();
                link.click();
            }

            loadImage(file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        // Clear canvas and draw image
                        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                        this.ctx.drawImage(img, 0, 0, this.canvas.width, this.canvas.height);
                        this.generateParticles();
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            }

            animate() {
                // Clear canvas
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                // Update and draw particles
                this.particles.forEach(particle => {
                    particle.update(this.mouseX, this.mouseY, this.mouseActive, this.settings);
                    particle.draw(this.ctx);
                });

                this.animationId = requestAnimationFrame(() => this.animate());
            }

            startAnimation() {
                this.animate();
            }

            stopAnimation() {
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                }
            }
        }

        // Initialize the app when the page loads
        window.addEventListener('load', () => {
            new ForceFieldApp();
        });
    </script>
</body>
</html> 